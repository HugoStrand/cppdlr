..
   Generated automatically by cpp2rst

.. highlight:: c
.. role:: red
.. role:: green
.. role:: param


.. _cppdlr__imtime_ops__convmat:

cppdlr::imtime_ops::convmat
===========================

*#include <cppdlr/imtime_ops.hpp>*



**Synopsis**

 .. rst-class:: cppsynopsis

       | :green:`template<typename T, typename S = nda::get_value_t<T>`
       | nda::matrix<S> :red:`convmat` (double :param:`beta`,
       |          statistic_t :param:`statistic`,
       |          T const & :param:`fc`,
       |          bool :param:`time_order` = false) const











Returns
^^^^^^^

Matrix of convolution by f

 \note Whereas the method imtime_ops::convolve takes the DLR coefficients
 of f and g as input and computes their convolution h directly, this method
 returns a matrix which should be applied to the DLR imaginary time grid values
 of g, rather than its DLR coefficients, in to order to obtain the
 convolution h. The purpose of this is to make the input and output
 representations of the convolution matrix equal, which is often convenient
 in practice.

 \note In the case of matrix-valued Green's functions, we think of the
 matrix of convolution by f as an r*norb x r*norb matrix, or a block r x r
 matrix of norb x norb blocks. Here r is the DLR rank and norb is the
 number of orbital indices. This matrix would then be applied to a Green's
 function g, represented as an r*norb x norb matrix, or a block r x 1
 matrix of norb x norb blocks.