<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppdlr: cppdlr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cppdlr<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Imaginary time calculations using the discrete Lehmann representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">cppdlr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1barycheb.html">barycheb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1dyson__it.html">dyson_it</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for solving Dyson equation in imaginary time.  <a href="classcppdlr_1_1dyson__it.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class containing parameters for fine composite Chebyshev grid discretizations of imaginary time and frequency.  <a href="classcppdlr_1_1fineparams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imfreq__ops.html">imfreq_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary frequency operations, including building imaginary frequency grid and transformations.  <a href="classcppdlr_1_1imfreq__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations.  <a href="classcppdlr_1_1imtime__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of given nda MemoryArray with scalar value type replaced by common type of two given types (real if both are real, complex otherwise)  <a href="structcppdlr_1_1make__common__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83cde5c4ed014eb53f7c16392a41733e"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a83cde5c4ed014eb53f7c16392a41733e">build_rf_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:a83cde5c4ed014eb53f7c16392a41733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build fine composite Chebyshev grid in real frequency.  <br /></td></tr>
<tr class="separator:a83cde5c4ed014eb53f7c16392a41733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d66881c7086a1f6fc2452f10bc9bc0"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a04d66881c7086a1f6fc2452f10bc9bc0">build_it_fine</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine)</td></tr>
<tr class="memdesc:a04d66881c7086a1f6fc2452f10bc9bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fine composite Chebyshev grid in imaginary time.  <br /></td></tr>
<tr class="separator:a04d66881c7086a1f6fc2452f10bc9bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c50dbbe81c1821676393f8584fb3f6"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a38c50dbbe81c1821676393f8584fb3f6">build_k_it</a> (nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om)</td></tr>
<tr class="memdesc:a38c50dbbe81c1821676393f8584fb3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary time discretization of analytic continuation kernel.  <br /></td></tr>
<tr class="separator:a38c50dbbe81c1821676393f8584fb3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb848c5a66d6141ad240d2e749aec9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a48fb848c5a66d6141ad240d2e749aec9">geterr_k_it</a> (<a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;fine, nda::vector_const_view&lt; double &gt; t, nda::vector_const_view&lt; double &gt; om, nda::matrix_const_view&lt; double &gt; kmat)</td></tr>
<tr class="memdesc:a48fb848c5a66d6141ad240d2e749aec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time.  <br /></td></tr>
<tr class="separator:a48fb848c5a66d6141ad240d2e749aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f80420d11cd80ac3803bd3bd429c0"><td class="memItemLeft" align="right" valign="top">nda::matrix&lt; dcomplex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a988f80420d11cd80ac3803bd3bd429c0">build_k_if</a> (int nmax, nda::vector_const_view&lt; double &gt; om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:a988f80420d11cd80ac3803bd3bd429c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get imaginary frequency discretization of analytic continuation kernel.  <br /></td></tr>
<tr class="separator:a988f80420d11cd80ac3803bd3bd429c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84f47b6cc94a562dfd5207791c27b0"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ace84f47b6cc94a562dfd5207791c27b0">build_dlr_rf</a> (double lambda, double eps)</td></tr>
<tr class="memdesc:ace84f47b6cc94a562dfd5207791c27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct DLR basis by obtaining DLR frequencies.  <br /></td></tr>
<tr class="separator:ace84f47b6cc94a562dfd5207791c27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52a76483a86cc380b2bfb324a6fdbcb"><td class="memTemplParams" colspan="2">template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</td></tr>
<tr class="memitem:af52a76483a86cc380b2bfb324a6fdbcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af52a76483a86cc380b2bfb324a6fdbcb">free_gf</a> (double beta, <a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;itops, Ht const &amp;h, double mu=0)</td></tr>
<tr class="memdesc:af52a76483a86cc380b2bfb324a6fdbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute free-particle imaginary time Green's function for a given Hamiltonian.  <br /></td></tr>
<tr class="separator:af52a76483a86cc380b2bfb324a6fdbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9726e02898098dfff8448f02f5b3c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afc9726e02898098dfff8448f02f5b3c6">k_it</a> (double t, double om)</td></tr>
<tr class="memdesc:afc9726e02898098dfff8448f02f5b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:afc9726e02898098dfff8448f02f5b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc4afda9cacac00e93425fe9d45a93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3cfc4afda9cacac00e93425fe9d45a93">k_it</a> (double t, double om, double beta)</td></tr>
<tr class="memdesc:a3cfc4afda9cacac00e93425fe9d45a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature.  <br /></td></tr>
<tr class="separator:a3cfc4afda9cacac00e93425fe9d45a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfaf907221eb1768418258421af703f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a7dfaf907221eb1768418258421af703f">k_it_abs</a> (double t, double om)</td></tr>
<tr class="memdesc:a7dfaf907221eb1768418258421af703f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:a7dfaf907221eb1768418258421af703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66270b210c46b39737f361467f645be7"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a66270b210c46b39737f361467f645be7">k_if_fermion</a> (int n, double om)</td></tr>
<tr class="separator:a66270b210c46b39737f361467f645be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73f52d9e0209e584d1210d419f39f8c"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ab73f52d9e0209e584d1210d419f39f8c">k_if_boson</a> (int n, double om)</td></tr>
<tr class="separator:ab73f52d9e0209e584d1210d419f39f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af8f77e12b089b5ddb5b5b3cda18cf623">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic)</td></tr>
<tr class="memdesc:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1)  <br /></td></tr>
<tr class="separator:af8f77e12b089b5ddb5b5b3cda18cf623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672098c598c55c8f9da60cd194a741ea"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a672098c598c55c8f9da60cd194a741ea">k_if</a> (int n, double om, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> statistic, double beta)</td></tr>
<tr class="memdesc:a672098c598c55c8f9da60cd194a741ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature.  <br /></td></tr>
<tr class="separator:a672098c598c55c8f9da60cd194a741ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46bf12944fe36c90343df67e2d783b"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a2d46bf12944fe36c90343df67e2d783b">eqptsrel</a> (int n)</td></tr>
<tr class="memdesc:a2d46bf12944fe36c90343df67e2d783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get grid of equispaced points on [0,1] in relative time format.  <br /></td></tr>
<tr class="separator:a2d46bf12944fe36c90343df67e2d783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ccba6393dfc517757677a13ad2553"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3b1ccba6393dfc517757677a13ad2553">rel2abs</a> (nda::vector_const_view&lt; double &gt; t)</td></tr>
<tr class="memdesc:a3b1ccba6393dfc517757677a13ad2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from relative to absolute time format.  <br /></td></tr>
<tr class="separator:a3b1ccba6393dfc517757677a13ad2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a8aae4c8af512d2682d381a676561"><td class="memItemLeft" align="right" valign="top">nda::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a103a8aae4c8af512d2682d381a676561">abs2rel</a> (nda::vector_const_view&lt; double &gt; t_abs)</td></tr>
<tr class="memdesc:a103a8aae4c8af512d2682d381a676561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert points on [0,1] from absolute to relative time format.  <br /></td></tr>
<tr class="separator:a103a8aae4c8af512d2682d381a676561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfcb627a6ab1115bb02670e7ce61219"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#afbfcb627a6ab1115bb02670e7ce61219">gaussquad</a> (int n)</td></tr>
<tr class="memdesc:afbfcb627a6ab1115bb02670e7ce61219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Legendre nodes and weights.  <br /></td></tr>
<tr class="separator:afbfcb627a6ab1115bb02670e7ce61219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcede29d3876b4a265f09a56db33085d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#adcede29d3876b4a265f09a56db33085d">leg_eval</a> (int n, double x)</td></tr>
<tr class="memdesc:adcede29d3876b4a265f09a56db33085d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Legendre polynomial of degree n and its derivative.  <br /></td></tr>
<tr class="separator:adcede29d3876b4a265f09a56db33085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d95a6e52d5747f0ea12b91160734e8d"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, typename S  = get_value_t&lt;T&gt;&gt; <br />
requires (nda::is_scalar_v&lt;S&gt;)</td></tr>
<tr class="memitem:a3d95a6e52d5747f0ea12b91160734e8d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a3d95a6e52d5747f0ea12b91160734e8d">pivrgs</a> (T const &amp;a, double eps)</td></tr>
<tr class="memdesc:a3d95a6e52d5747f0ea12b91160734e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank-revealing pivoted reorthogonalized Gram-Schmidt.  <br /></td></tr>
<tr class="separator:a3d95a6e52d5747f0ea12b91160734e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b3f78817239e2d1653be8972cc5f1"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = typename std::common_type&lt;Sa, Sb&gt;::type&gt; </td></tr>
<tr class="memitem:a623b3f78817239e2d1653be8972cc5f1"><td class="memTemplItemLeft" align="right" valign="top">nda::array&lt; S, Ta::rank+Tb::rank - 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a623b3f78817239e2d1653be8972cc5f1">arraymult</a> (Ta const &amp;a, Tb const &amp;b)</td></tr>
<tr class="memdesc:a623b3f78817239e2d1653be8972cc5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the last dimension of an array a with the first dimension of an array b.  <br /></td></tr>
<tr class="separator:a623b3f78817239e2d1653be8972cc5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a93826a1ab8ed29d304e0194fefd4e19c">adapgl</a> (std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt; f, double a, double b, double tol, nda::vector&lt; double &gt; xgl, nda::vector&lt; double &gt; wgl)</td></tr>
<tr class="memdesc:a93826a1ab8ed29d304e0194fefd4e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick and dirty adaptive Gauss quadrature.  <br /></td></tr>
<tr class="separator:a93826a1ab8ed29d304e0194fefd4e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a129c05d03fc8311641a3187782ee074d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespacecppdlr.html#a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb">ORDINARY</a> = false
, <a class="el" href="namespacecppdlr.html#a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6">TIME_ORDERED</a> = true
 }</td></tr>
<tr class="separator:a129c05d03fc8311641a3187782ee074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7e33d9a03f4986937032c25ee7435"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a> { <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d">Boson</a> = 0
, <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee">Fermion</a> = 1
 }</td></tr>
<tr class="separator:ad0a7e33d9a03f4986937032c25ee7435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a85cd7bdb1fd649296322df16d329ca27"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:a85cd7bdb1fd649296322df16d329ca27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#a85cd7bdb1fd649296322df16d329ca27">make_real_t</a> = decltype(make_regular(real(std::declval&lt; T &gt;())))</td></tr>
<tr class="memdesc:a85cd7bdb1fd649296322df16d329ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get real-valued type corresponding to type of given nda MemoryArray.  <br /></td></tr>
<tr class="separator:a85cd7bdb1fd649296322df16d329ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T&gt; </td></tr>
<tr class="memitem:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">make_cplx_t</a> = decltype(make_regular(std::declval&lt; T &gt;() *1i))</td></tr>
<tr class="memdesc:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get complex-valued type corresponding to type of given nda MemoryArray.  <br /></td></tr>
<tr class="separator:af7426dd83d2c831f6ae3fa9b8e6172ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplParams" colspan="2">template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </td></tr>
<tr class="memitem:ac23dfec829ec6ed8deec469faeea3981"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">make_common_t</a> = typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt; T, S1, S2 &gt;::type</td></tr>
<tr class="separator:ac23dfec829ec6ed8deec469faeea3981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac23dfec829ec6ed8deec469faeea3981" name="ac23dfec829ec6ed8deec469faeea3981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23dfec829ec6ed8deec469faeea3981">&#9670;&#160;</a></span>make_common_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T, nda::Scalar S1, nda::Scalar S2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#ac23dfec829ec6ed8deec469faeea3981">cppdlr::make_common_t</a> = typedef typename <a class="el" href="structcppdlr_1_1make__common__helper.html">make_common_helper</a>&lt;T, S1, S2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7426dd83d2c831f6ae3fa9b8e6172ad" name="af7426dd83d2c831f6ae3fa9b8e6172ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7426dd83d2c831f6ae3fa9b8e6172ad">&#9670;&#160;</a></span>make_cplx_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#af7426dd83d2c831f6ae3fa9b8e6172ad">cppdlr::make_cplx_t</a> = typedef decltype(make_regular(std::declval&lt;T&gt;() * 1i))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get complex-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<a id="a85cd7bdb1fd649296322df16d329ca27" name="a85cd7bdb1fd649296322df16d329ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cd7bdb1fd649296322df16d329ca27">&#9670;&#160;</a></span>make_real_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecppdlr.html#a85cd7bdb1fd649296322df16d329ca27">cppdlr::make_real_t</a> = typedef decltype(make_regular(real(std::declval&lt;T&gt;())))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get real-valued type corresponding to type of given nda MemoryArray. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a129c05d03fc8311641a3187782ee074d" name="a129c05d03fc8311641a3187782ee074d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129c05d03fc8311641a3187782ee074d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Option for ordinary or time-ordered convolution </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb" name="a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb"></a>ORDINARY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6" name="a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6"></a>TIME_ORDERED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad0a7e33d9a03f4986937032c25ee7435" name="ad0a7e33d9a03f4986937032c25ee7435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a7e33d9a03f4986937032c25ee7435">&#9670;&#160;</a></span>statistic_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">cppdlr::statistic_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Particle Statistic: Boson or Fermion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d" name="ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d"></a>Boson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee" name="ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee"></a>Fermion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a103a8aae4c8af512d2682d381a676561" name="a103a8aae4c8af512d2682d381a676561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a8aae4c8af512d2682d381a676561">&#9670;&#160;</a></span>abs2rel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::abs2rel </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t_abs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from absolute to relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_abs</td><td>Vector of points on [0,1] in absolute time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in relative time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>cppdlr uses the relative time format to describe imaginary time points. Therefore, if you wish to specify an imaginary time point in the standard absolute time format, for example to specify a point at which to evaluate a DLR expansion, you must first convert the point to the relative time format using this function. However, in order to maintain full relative precision in all calculations, you must conform to the cppdlr standard and specify point in the relative time format from the beginning. On the other hand, in most cases only a mild loss of accuracy will result from beginning with the absolute format and then converting to the relative format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
<a id="a93826a1ab8ed29d304e0194fefd4e19c" name="a93826a1ab8ed29d304e0194fefd4e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93826a1ab8ed29d304e0194fefd4e19c">&#9670;&#160;</a></span>adapgl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S cppdlr::adapgl </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; nda::array&lt; S, 1 &gt;(nda::array&lt; double, 1 &gt;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>xgl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>wgl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick and dirty adaptive Gauss quadrature. </p>
<p>This function implements adaptive Gauss-Legendre quadrature with local error estimation only, using a stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function to be integrated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Lower integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Upper integration limit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Absolute error tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xgl</td><td>Gauss-Legendre nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wgl</td><td>Gauss-Legendre weights</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral of <code>f</code> from <code>a</code> to <code>b</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a quick and dirty adaptive integration function, which tries to achieve an error tolerance <code>tol</code> but doesn't guarantee it. A more robust implementation would use global error estimation. Nevertheless, this works quite well most of the time. </dd></dl>

</div>
</div>
<a id="a623b3f78817239e2d1653be8972cc5f1" name="a623b3f78817239e2d1653be8972cc5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b3f78817239e2d1653be8972cc5f1">&#9670;&#160;</a></span>arraymult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArray Ta, nda::MemoryArray Tb, nda::Scalar Sa = nda::get_value_t&lt;Ta&gt;, nda::Scalar Sb = nda::get_value_t&lt;Tb&gt;, nda::Scalar S = typename std::common_type&lt;Sa, Sb&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">nda::array&lt; S, Ta::rank+Tb::rank - 2 &gt; cppdlr::arraymult </td>
          <td>(</td>
          <td class="paramtype">Ta const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract the last dimension of an array a with the first dimension of an array b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2 </td></tr>
    <tr><td class="paramname">b</td><td>An array/matrix/vector or array/matrix/vector view of rank at least 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contraction of the inner dimensions of <code>a</code> and <code>b</code> </dd></dl>

</div>
</div>
<a id="ace84f47b6cc94a562dfd5207791c27b0" name="ace84f47b6cc94a562dfd5207791c27b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace84f47b6cc94a562dfd5207791c27b0">&#9670;&#160;</a></span>build_dlr_rf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_dlr_rf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct DLR basis by obtaining DLR frequencies. </p>
<p>Construct DLR basis for a given accuracy and cutoff parameter by getting DLR frequencies </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>DLR cutoff parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Accuracy of DLR basis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLR frequencies </dd></dl>

</div>
</div>
<a id="a04d66881c7086a1f6fc2452f10bc9bc0" name="a04d66881c7086a1f6fc2452f10bc9bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d66881c7086a1f6fc2452f10bc9bc0">&#9670;&#160;</a></span>build_it_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_it_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fine composite Chebyshev grid in imaginary time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fine imaginary time grid</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Fine imaginary time grid is given in relative format </dd></dl>

</div>
</div>
<a id="a988f80420d11cd80ac3803bd3bd429c0" name="a988f80420d11cd80ac3803bd3bd429c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f80420d11cd80ac3803bd3bd429c0">&#9670;&#160;</a></span>build_k_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; dcomplex &gt; cppdlr::build_k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary frequency discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmax</td><td>Imaginary frequency cutoff </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a38c50dbbe81c1821676393f8584fb3f6" name="a38c50dbbe81c1821676393f8584fb3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c50dbbe81c1821676393f8584fb3f6">&#9670;&#160;</a></span>build_k_it()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::matrix&lt; double &gt; cppdlr::build_k_it </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get imaginary time discretization of analytic continuation kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Frequency real grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Discretization of analytic continuation kernel on given grid </dd></dl>

</div>
</div>
<a id="a83cde5c4ed014eb53f7c16392a41733e" name="a83cde5c4ed014eb53f7c16392a41733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cde5c4ed014eb53f7c16392a41733e">&#9670;&#160;</a></span>build_rf_fine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::build_rf_fine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build fine composite Chebyshev grid in real frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fine real frequency grid </dd></dl>

</div>
</div>
<a id="a2d46bf12944fe36c90343df67e2d783b" name="a2d46bf12944fe36c90343df67e2d783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d46bf12944fe36c90343df67e2d783b">&#9670;&#160;</a></span>eqptsrel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::eqptsrel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get grid of equispaced points on [0,1] in relative time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of equispaced points on [0,1] in relative time format </dd></dl>

</div>
</div>
<a id="af52a76483a86cc380b2bfb324a6fdbcb" name="af52a76483a86cc380b2bfb324a6fdbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52a76483a86cc380b2bfb324a6fdbcb">&#9670;&#160;</a></span>free_gf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ht &gt; <br />
requires (std::floating_point&lt;Ht&gt; || nda::MemoryMatrix&lt;Ht&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppdlr::free_gf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1imtime__ops.html">imtime_ops</a> const &amp;&#160;</td>
          <td class="paramname"><em>itops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ht const &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute free-particle imaginary time Green's function for a given Hamiltonian. </p>
<p>The Green's function is computed by diagonalizing the Hamiltonian, and is returned by its values at the DLR imaginary time nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td><a class="el" href="classcppdlr_1_1imtime__ops.html" title="Class responsible for all DLR imaginary time operations, including building imaginary time grid and t...">imtime_ops</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hamiltonian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Chemical potential</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Green's function at DLR imaginary time nodes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar. </dd></dl>

</div>
</div>
<a id="afbfcb627a6ab1115bb02670e7ce61219" name="afbfcb627a6ab1115bb02670e7ce61219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfcb627a6ab1115bb02670e7ce61219">&#9670;&#160;</a></span>gaussquad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; nda::vector&lt; double &gt;, nda::vector&lt; double &gt; &gt; cppdlr::gaussquad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gauss-Legendre nodes and weights. </p>
<p>Uses Newton iteration to obtain the Gauss-Legendre nodes and weights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of nodes and weights </dd></dl>

</div>
</div>
<a id="a48fb848c5a66d6141ad240d2e749aec9" name="a48fb848c5a66d6141ad240d2e749aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fb848c5a66d6141ad240d2e749aec9">&#9670;&#160;</a></span>geterr_k_it()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::geterr_k_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdlr_1_1fineparams.html">fineparams</a> &amp;&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nda::matrix_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>kmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fine</td><td>Fine grid parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time grid in relative format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmat</td><td>Discretization of analytic continuation kernel on given grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error of given fine discretization of analytic continuation kernel in imaginary time and real frequency</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Error is given as an estimate of the maximum absolute value of the difference between the given discretization and the exact analytic continuation kernel</dd>
<dd>
<code>kmat</code> should be computed using the function get_kfine with composite Chebyshev grids produced by get_omfine and get_tfine </dd></dl>

</div>
</div>
<a id="af8f77e12b089b5ddb5b5b3cda18cf623" name="af8f77e12b089b5ddb5b5b3cda18cf623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f77e12b089b5ddb5b5b3cda18cf623">&#9670;&#160;</a></span>k_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi (fermionic case) or i nu_n = 2n * i * pi (bosonic case). </dd></dl>

</div>
</div>
<a id="a672098c598c55c8f9da60cd194a741ea" name="a672098c598c55c8f9da60cd194a741ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672098c598c55c8f9da60cd194a741ea">&#9670;&#160;</a></span>k_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecppdlr.html#ad0a7e33d9a03f4986937032c25ee7435">statistic_t</a>&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Imaginary frequency index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statistic</td><td>Particle Statistic: Boson or Fermion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(i nu_n,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(i nu_n, om) = 1 / (i nu_n - om) with i nu_n = (2n+1) * i * pi / beta (fermionic case) or i nu_n = 2n * i * pi / beta (bosonic case). </dd></dl>

</div>
</div>
<a id="ab73f52d9e0209e584d1210d419f39f8c" name="ab73f52d9e0209e584d1210d419f39f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73f52d9e0209e584d1210d419f39f8c">&#9670;&#160;</a></span>k_if_boson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if_boson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66270b210c46b39737f361467f645be7" name="a66270b210c46b39737f361467f645be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66270b210c46b39737f361467f645be7">&#9670;&#160;</a></span>k_if_fermion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; cppdlr::k_if_fermion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9726e02898098dfff8448f02f5b3c6" name="afc9726e02898098dfff8448f02f5b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9726e02898098dfff8448f02f5b3c6">&#9670;&#160;</a></span>k_it() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="a3cfc4afda9cacac00e93425fe9d45a93" name="a3cfc4afda9cacac00e93425fe9d45a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfc4afda9cacac00e93425fe9d45a93">&#9670;&#160;</a></span>k_it() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (relative format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>Inverse temperature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel at a given inverse temperature beta is K(t,om) = -exp(-t*om)/(1+exp(-beta * om)). </dd></dl>

</div>
</div>
<a id="a7dfaf907221eb1768418258421af703f" name="a7dfaf907221eb1768418258421af703f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfaf907221eb1768418258421af703f">&#9670;&#160;</a></span>k_it_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cppdlr::k_it_abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>om</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Imaginary time value (absolute format) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">om</td><td>Real frequency value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value K(t,om) of analytic continuation kernel</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -exp(-t * om)/(1 + exp(-om)). </dd></dl>

</div>
</div>
<a id="adcede29d3876b4a265f09a56db33085d" name="adcede29d3876b4a265f09a56db33085d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcede29d3876b4a265f09a56db33085d">&#9670;&#160;</a></span>leg_eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double &gt; cppdlr::leg_eval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate Legendre polynomial of degree n and its derivative. </p>
<p>Uses Legendre three-term recurrence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Degree of polynomial Pn(x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Point at which to evaluate polynomial</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of polynomial value Pn(x) and derivative Pn'(x) </dd></dl>

</div>
</div>
<a id="a3d95a6e52d5747f0ea12b91160734e8d" name="a3d95a6e52d5747f0ea12b91160734e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d95a6e52d5747f0ea12b91160734e8d">&#9670;&#160;</a></span>pivrgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;nda::MemoryArrayOfRank&lt; 2 &gt; T, typename S  = get_value_t&lt;T&gt;&gt; <br />
requires (nda::is_scalar_v&lt;S&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; typename T::regular_type, nda::vector&lt; double &gt;, nda::vector&lt; int &gt; &gt; cppdlr::pivrgs </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rank-revealing pivoted reorthogonalized Gram-Schmidt. </p>
<p>Determine the epsilon-rank of a matrix and return an orthogonal basis of its epsilon-row space.</p>
<p>This is a translation of the Fortran subroutine "qrdgrm" by V. Rokhlin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix to be orthogonalized </td></tr>
    <tr><td class="paramname">eps</td><td>Rank cutoff tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (1) matrix containing whose rows form orthogonal basis of row space of <code>a</code> to <code>eps</code> tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-1 selected rows, (3) vector of pivots </dd></dl>

</div>
</div>
<a id="a3b1ccba6393dfc517757677a13ad2553" name="a3b1ccba6393dfc517757677a13ad2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ccba6393dfc517757677a13ad2553">&#9670;&#160;</a></span>rel2abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nda::vector&lt; double &gt; cppdlr::rel2abs </td>
          <td>(</td>
          <td class="paramtype">nda::vector_const_view&lt; double &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert points on [0,1] from relative to absolute time format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Vector of points on [0,1] in relative time format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of points on [0,1] in absolute time format</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-digit arithmetic, the point t = 0.999111 could be stored in relative format as t^* = -0.889e-3, but only as t = 0.999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
