\hypertarget{namespacecppdlr}{}\doxysection{cppdlr Namespace Reference}
\label{namespacecppdlr}\index{cppdlr@{cppdlr}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classcppdlr_1_1barycheb}{barycheb}}
\item 
class \mbox{\hyperlink{classcppdlr_1_1dyson__it}{dyson\+\_\+it}}
\begin{DoxyCompactList}\small\item\em Class for solving Dyson equation in imaginary time. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}}
\begin{DoxyCompactList}\small\item\em Class containing parameters for fine composite Chebyshev grid discretizations of imaginary time and frequency. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcppdlr_1_1imfreq__ops}{imfreq\+\_\+ops}}
\begin{DoxyCompactList}\small\item\em Class responsible for all DLR imaginary frequency operations, including building imaginary frequency grid and transformations. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}}
\begin{DoxyCompactList}\small\item\em Class responsible for all DLR imaginary time operations, including building imaginary time grid and transformations. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcppdlr_1_1make__common__helper}{make\+\_\+common\+\_\+helper}}
\begin{DoxyCompactList}\small\item\em Get type of given nda Memory\+Array with scalar value type replaced by common type of two given types (real if both are real, complex otherwise) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a83cde5c4ed014eb53f7c16392a41733e}{build\+\_\+rf\+\_\+fine}} (\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&fine)
\begin{DoxyCompactList}\small\item\em Build fine composite Chebyshev grid in real frequency. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a04d66881c7086a1f6fc2452f10bc9bc0}{build\+\_\+it\+\_\+fine}} (\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&fine)
\begin{DoxyCompactList}\small\item\em Get fine composite Chebyshev grid in imaginary time. \end{DoxyCompactList}\item 
nda\+::matrix$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a38c50dbbe81c1821676393f8584fb3f6}{build\+\_\+k\+\_\+it}} (nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ t, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ om)
\begin{DoxyCompactList}\small\item\em Get imaginary time discretization of analytic continuation kernel. \end{DoxyCompactList}\item 
std\+::tuple$<$ double, double $>$ \mbox{\hyperlink{namespacecppdlr_a48fb848c5a66d6141ad240d2e749aec9}{geterr\+\_\+k\+\_\+it}} (\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&fine, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ t, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ om, nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$ kmat)
\begin{DoxyCompactList}\small\item\em Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time. \end{DoxyCompactList}\item 
nda\+::matrix$<$ dcomplex $>$ \mbox{\hyperlink{namespacecppdlr_a988f80420d11cd80ac3803bd3bd429c0}{build\+\_\+k\+\_\+if}} (int nmax, nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ om, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} statistic)
\begin{DoxyCompactList}\small\item\em Get imaginary frequency discretization of analytic continuation kernel. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_ace84f47b6cc94a562dfd5207791c27b0}{build\+\_\+dlr\+\_\+rf}} (double lambda, double eps)
\begin{DoxyCompactList}\small\item\em Construct DLR basis by obtaining DLR frequencies. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Ht $>$ \newline
requires (std\+::floating\+\_\+point$<$Ht$>$ $\vert$$\vert$ nda\+::\+Memory\+Matrix$<$Ht$>$)}\\auto \mbox{\hyperlink{namespacecppdlr_af52a76483a86cc380b2bfb324a6fdbcb}{free\+\_\+gf}} (double beta, \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} const \&itops, Ht const \&h, double mu=0)
\begin{DoxyCompactList}\small\item\em Compute free-\/particle imaginary time Green\textquotesingle{}s function for a given Hamiltonian. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacecppdlr_afc9726e02898098dfff8448f02f5b3c6}{k\+\_\+it}} (double t, double om)
\begin{DoxyCompactList}\small\item\em Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1) \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacecppdlr_a3cfc4afda9cacac00e93425fe9d45a93}{k\+\_\+it}} (double t, double om, double beta)
\begin{DoxyCompactList}\small\item\em Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacecppdlr_a7dfaf907221eb1768418258421af703f}{k\+\_\+it\+\_\+abs}} (double t, double om)
\begin{DoxyCompactList}\small\item\em Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1) \end{DoxyCompactList}\item 
std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a66270b210c46b39737f361467f645be7}{k\+\_\+if\+\_\+fermion}} (int n, double om)
\item 
std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_ab73f52d9e0209e584d1210d419f39f8c}{k\+\_\+if\+\_\+boson}} (int n, double om)
\item 
std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_af8f77e12b089b5ddb5b5b3cda18cf623}{k\+\_\+if}} (int n, double om, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} statistic)
\begin{DoxyCompactList}\small\item\em Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) \end{DoxyCompactList}\item 
std\+::complex$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a672098c598c55c8f9da60cd194a741ea}{k\+\_\+if}} (int n, double om, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} statistic, double beta)
\begin{DoxyCompactList}\small\item\em Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a2d46bf12944fe36c90343df67e2d783b}{eqptsrel}} (int n)
\begin{DoxyCompactList}\small\item\em Get grid of equispaced points on \mbox{[}0,1\mbox{]} in relative time format. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a3b1ccba6393dfc517757677a13ad2553}{rel2abs}} (nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ t)
\begin{DoxyCompactList}\small\item\em Convert points on \mbox{[}0,1\mbox{]} from relative to absolute time format. \end{DoxyCompactList}\item 
nda\+::vector$<$ double $>$ \mbox{\hyperlink{namespacecppdlr_a103a8aae4c8af512d2682d381a676561}{abs2rel}} (nda\+::vector\+\_\+const\+\_\+view$<$ double $>$ t\+\_\+abs)
\begin{DoxyCompactList}\small\item\em Convert points on \mbox{[}0,1\mbox{]} from absolute to relative time format. \end{DoxyCompactList}\item 
std\+::tuple$<$ nda\+::vector$<$ double $>$, nda\+::vector$<$ double $>$ $>$ \mbox{\hyperlink{namespacecppdlr_afbfcb627a6ab1115bb02670e7ce61219}{gaussquad}} (int n)
\begin{DoxyCompactList}\small\item\em Gauss-\/\+Legendre nodes and weights. \end{DoxyCompactList}\item 
std\+::tuple$<$ double, double $>$ \mbox{\hyperlink{namespacecppdlr_adcede29d3876b4a265f09a56db33085d}{leg\+\_\+eval}} (int n, double x)
\begin{DoxyCompactList}\small\item\em Evaluate Legendre polynomial of degree n and its derivative. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array\+Of\+Rank$<$ 2 $>$ T, typename S  = get\+\_\+value\+\_\+t$<$\+T$>$$>$ \newline
requires (nda\+::is\+\_\+scalar\+\_\+v$<$S$>$)}\\std\+::tuple$<$ typename T\+::regular\+\_\+type, nda\+::vector$<$ double $>$, nda\+::vector$<$ int $>$ $>$ \mbox{\hyperlink{namespacecppdlr_a3d95a6e52d5747f0ea12b91160734e8d}{pivrgs}} (T const \&a, double eps)
\begin{DoxyCompactList}\small\item\em Rank-\/revealing pivoted reorthogonalized Gram-\/\+Schmidt. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array Ta, nda\+::\+Memory\+Array Tb, nda\+::\+Scalar Sa = nda\+::get\+\_\+value\+\_\+t$<$\+Ta$>$, nda\+::\+Scalar Sb = nda\+::get\+\_\+value\+\_\+t$<$\+Tb$>$, nda\+::\+Scalar S = typename std\+::common\+\_\+type$<$\+Sa, Sb$>$\+::type$>$ }\\nda\+::array$<$ S, Ta\+::rank+Tb\+::rank -\/ 2 $>$ \mbox{\hyperlink{namespacecppdlr_a623b3f78817239e2d1653be8972cc5f1}{arraymult}} (Ta const \&a, Tb const \&b)
\begin{DoxyCompactList}\small\item\em Contract the last dimension of an array a with the first dimension of an array b. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename S $>$ }\\S \mbox{\hyperlink{namespacecppdlr_a93826a1ab8ed29d304e0194fefd4e19c}{adapgl}} (std\+::function$<$ nda\+::array$<$ S, 1 $>$(nda\+::array$<$ double, 1 $>$)$>$ f, double a, double b, double tol, nda\+::vector$<$ double $>$ xgl, nda\+::vector$<$ double $>$ wgl)
\begin{DoxyCompactList}\small\item\em Quick and dirty adaptive Gauss quadrature. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \{ \mbox{\hyperlink{namespacecppdlr_a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb}{ORDINARY}} = false
, \mbox{\hyperlink{namespacecppdlr_a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6}{TIME\+\_\+\+ORDERED}} = true
 \}
\item 
enum \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}} \{ \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d}{Boson}} = 0
, \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee}{Fermion}} = 1
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T$>$ }\\using \mbox{\hyperlink{namespacecppdlr_a85cd7bdb1fd649296322df16d329ca27}{make\+\_\+real\+\_\+t}} = decltype(make\+\_\+regular(real(std\+::declval$<$ T $>$())))
\begin{DoxyCompactList}\small\item\em Get real-\/valued type corresponding to type of given nda Memory\+Array. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T$>$ }\\using \mbox{\hyperlink{namespacecppdlr_af7426dd83d2c831f6ae3fa9b8e6172ad}{make\+\_\+cplx\+\_\+t}} = decltype(make\+\_\+regular(std\+::declval$<$ T $>$() $\ast$1i))
\begin{DoxyCompactList}\small\item\em Get complex-\/valued type corresponding to type of given nda Memory\+Array. \end{DoxyCompactList}\item 
{\footnotesize template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S1, nda\+::\+Scalar S2$>$ }\\using \mbox{\hyperlink{namespacecppdlr_ac23dfec829ec6ed8deec469faeea3981}{make\+\_\+common\+\_\+t}} = typename \mbox{\hyperlink{structcppdlr_1_1make__common__helper}{make\+\_\+common\+\_\+helper}}$<$ T, S1, S2 $>$\+::type
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespacecppdlr_ac23dfec829ec6ed8deec469faeea3981}\label{namespacecppdlr_ac23dfec829ec6ed8deec469faeea3981}} 
\index{cppdlr@{cppdlr}!make\_common\_t@{make\_common\_t}}
\index{make\_common\_t@{make\_common\_t}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{make\_common\_t}{make\_common\_t}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T, nda\+::\+Scalar S1, nda\+::\+Scalar S2$>$ \\
using \mbox{\hyperlink{namespacecppdlr_ac23dfec829ec6ed8deec469faeea3981}{cppdlr\+::make\+\_\+common\+\_\+t}} = typedef typename \mbox{\hyperlink{structcppdlr_1_1make__common__helper}{make\+\_\+common\+\_\+helper}}$<$T, S1, S2$>$\+::type}

\mbox{\Hypertarget{namespacecppdlr_af7426dd83d2c831f6ae3fa9b8e6172ad}\label{namespacecppdlr_af7426dd83d2c831f6ae3fa9b8e6172ad}} 
\index{cppdlr@{cppdlr}!make\_cplx\_t@{make\_cplx\_t}}
\index{make\_cplx\_t@{make\_cplx\_t}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{make\_cplx\_t}{make\_cplx\_t}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T$>$ \\
using \mbox{\hyperlink{namespacecppdlr_af7426dd83d2c831f6ae3fa9b8e6172ad}{cppdlr\+::make\+\_\+cplx\+\_\+t}} = typedef decltype(make\+\_\+regular(std\+::declval$<$T$>$() $\ast$ 1i))}



Get complex-\/valued type corresponding to type of given nda Memory\+Array. 

\mbox{\Hypertarget{namespacecppdlr_a85cd7bdb1fd649296322df16d329ca27}\label{namespacecppdlr_a85cd7bdb1fd649296322df16d329ca27}} 
\index{cppdlr@{cppdlr}!make\_real\_t@{make\_real\_t}}
\index{make\_real\_t@{make\_real\_t}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{make\_real\_t}{make\_real\_t}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array T$>$ \\
using \mbox{\hyperlink{namespacecppdlr_a85cd7bdb1fd649296322df16d329ca27}{cppdlr\+::make\+\_\+real\+\_\+t}} = typedef decltype(make\+\_\+regular(real(std\+::declval$<$T$>$())))}



Get real-\/valued type corresponding to type of given nda Memory\+Array. 



\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespacecppdlr_a129c05d03fc8311641a3187782ee074d}\label{namespacecppdlr_a129c05d03fc8311641a3187782ee074d}} 
\doxysubsubsection{\texorpdfstring{anonymous enum}{anonymous enum}}
{\footnotesize\ttfamily anonymous enum}

Option for ordinary or time-\/ordered convolution \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ORDINARY@{ORDINARY}!cppdlr@{cppdlr}}\index{cppdlr@{cppdlr}!ORDINARY@{ORDINARY}}}\mbox{\Hypertarget{namespacecppdlr_a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb}\label{namespacecppdlr_a129c05d03fc8311641a3187782ee074da196a077d1e896d9af1eaa919f5d55dcb}} 
ORDINARY&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{TIME\_ORDERED@{TIME\_ORDERED}!cppdlr@{cppdlr}}\index{cppdlr@{cppdlr}!TIME\_ORDERED@{TIME\_ORDERED}}}\mbox{\Hypertarget{namespacecppdlr_a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6}\label{namespacecppdlr_a129c05d03fc8311641a3187782ee074da25ad4cbf4bfe01f97a6f2e2e1b9781e6}} 
TIME\+\_\+\+ORDERED&\\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}\label{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}} 
\index{cppdlr@{cppdlr}!statistic\_t@{statistic\_t}}
\index{statistic\_t@{statistic\_t}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{statistic\_t}{statistic\_t}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{cppdlr\+::statistic\+\_\+t}}}

The Particle Statistic\+: Boson or Fermion \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Boson@{Boson}!cppdlr@{cppdlr}}\index{cppdlr@{cppdlr}!Boson@{Boson}}}\mbox{\Hypertarget{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d}\label{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435a6a57173d6b5be36c6815ab715152716d}} 
Boson&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Fermion@{Fermion}!cppdlr@{cppdlr}}\index{cppdlr@{cppdlr}!Fermion@{Fermion}}}\mbox{\Hypertarget{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee}\label{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435ac01c1699bb87ec8268ee33f7f20d84ee}} 
Fermion&\\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacecppdlr_a103a8aae4c8af512d2682d381a676561}\label{namespacecppdlr_a103a8aae4c8af512d2682d381a676561}} 
\index{cppdlr@{cppdlr}!abs2rel@{abs2rel}}
\index{abs2rel@{abs2rel}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{abs2rel()}{abs2rel()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::abs2rel (\begin{DoxyParamCaption}\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{t\+\_\+abs }\end{DoxyParamCaption})}



Convert points on \mbox{[}0,1\mbox{]} from absolute to relative time format. 


\begin{DoxyParams}{Parameters}
{\em t\+\_\+abs} & Vector of points on \mbox{[}0,1\mbox{]} in absolute time format\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of points on \mbox{[}0,1\mbox{]} in relative time format
\end{DoxyReturn}
\begin{DoxyNote}{Note}
cppdlr uses the relative time format to describe imaginary time points. Therefore, if you wish to specify an imaginary time point in the standard absolute time format, for example to specify a point at which to evaluate a DLR expansion, you must first convert the point to the relative time format using this function. However, in order to maintain full relative precision in all calculations, you must conform to the cppdlr standard and specify point in the relative time format from the beginning. On the other hand, in most cases only a mild loss of accuracy will result from beginning with the absolute format and then converting to the relative format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a93826a1ab8ed29d304e0194fefd4e19c}\label{namespacecppdlr_a93826a1ab8ed29d304e0194fefd4e19c}} 
\index{cppdlr@{cppdlr}!adapgl@{adapgl}}
\index{adapgl@{adapgl}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{adapgl()}{adapgl()}}
{\footnotesize\ttfamily template$<$typename S $>$ \\
S cppdlr\+::adapgl (\begin{DoxyParamCaption}\item[{std\+::function$<$ nda\+::array$<$ S, 1 $>$(nda\+::array$<$ double, 1 $>$)$>$}]{f,  }\item[{double}]{a,  }\item[{double}]{b,  }\item[{double}]{tol,  }\item[{nda\+::vector$<$ double $>$}]{xgl,  }\item[{nda\+::vector$<$ double $>$}]{wgl }\end{DoxyParamCaption})}



Quick and dirty adaptive Gauss quadrature. 

This function implements adaptive Gauss-\/\+Legendre quadrature with local error estimation only, using a stack.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & Function to be integrated \\
\hline
\mbox{\texttt{ in}}  & {\em a} & Lower integration limit \\
\hline
\mbox{\texttt{ in}}  & {\em b} & Upper integration limit \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & Absolute error tolerance \\
\hline
\mbox{\texttt{ in}}  & {\em xgl} & Gauss-\/\+Legendre nodes \\
\hline
\mbox{\texttt{ in}}  & {\em wgl} & Gauss-\/\+Legendre weights\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Integral of {\ttfamily f} from {\ttfamily a} to {\ttfamily b} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This is a quick and dirty adaptive integration function, which tries to achieve an error tolerance {\ttfamily tol} but doesn\textquotesingle{}t guarantee it. A more robust implementation would use global error estimation. Nevertheless, this works quite well most of the time. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a623b3f78817239e2d1653be8972cc5f1}\label{namespacecppdlr_a623b3f78817239e2d1653be8972cc5f1}} 
\index{cppdlr@{cppdlr}!arraymult@{arraymult}}
\index{arraymult@{arraymult}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{arraymult()}{arraymult()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array Ta, nda\+::\+Memory\+Array Tb, nda\+::\+Scalar Sa = nda\+::get\+\_\+value\+\_\+t$<$\+Ta$>$, nda\+::\+Scalar Sb = nda\+::get\+\_\+value\+\_\+t$<$\+Tb$>$, nda\+::\+Scalar S = typename std\+::common\+\_\+type$<$\+Sa, Sb$>$\+::type$>$ \\
nda\+::array$<$ S, Ta\+::rank+Tb\+::rank -\/ 2 $>$ cppdlr\+::arraymult (\begin{DoxyParamCaption}\item[{Ta const \&}]{a,  }\item[{Tb const \&}]{b }\end{DoxyParamCaption})}



Contract the last dimension of an array a with the first dimension of an array b. 


\begin{DoxyParams}{Parameters}
{\em a} & An array/matrix/vector or array/matrix/vector view of rank at least 2 \\
\hline
{\em b} & An array/matrix/vector or array/matrix/vector view of rank at least 2\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Contraction of the inner dimensions of {\ttfamily a} and {\ttfamily b} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_ace84f47b6cc94a562dfd5207791c27b0}\label{namespacecppdlr_ace84f47b6cc94a562dfd5207791c27b0}} 
\index{cppdlr@{cppdlr}!build\_dlr\_rf@{build\_dlr\_rf}}
\index{build\_dlr\_rf@{build\_dlr\_rf}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{build\_dlr\_rf()}{build\_dlr\_rf()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::build\+\_\+dlr\+\_\+rf (\begin{DoxyParamCaption}\item[{double}]{lambda,  }\item[{double}]{eps }\end{DoxyParamCaption})}



Construct DLR basis by obtaining DLR frequencies. 

Construct DLR basis for a given accuracy and cutoff parameter by getting DLR frequencies 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em lambda} & DLR cutoff parameter \\
\hline
\mbox{\texttt{ in}}  & {\em eps} & Accuracy of DLR basis\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
DLR frequencies 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a04d66881c7086a1f6fc2452f10bc9bc0}\label{namespacecppdlr_a04d66881c7086a1f6fc2452f10bc9bc0}} 
\index{cppdlr@{cppdlr}!build\_it\_fine@{build\_it\_fine}}
\index{build\_it\_fine@{build\_it\_fine}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{build\_it\_fine()}{build\_it\_fine()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::build\+\_\+it\+\_\+fine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&}]{fine }\end{DoxyParamCaption})}



Get fine composite Chebyshev grid in imaginary time. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fine} & Fine grid parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Fine imaginary time grid
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Fine imaginary time grid is given in relative format 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a988f80420d11cd80ac3803bd3bd429c0}\label{namespacecppdlr_a988f80420d11cd80ac3803bd3bd429c0}} 
\index{cppdlr@{cppdlr}!build\_k\_if@{build\_k\_if}}
\index{build\_k\_if@{build\_k\_if}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{build\_k\_if()}{build\_k\_if()}}
{\footnotesize\ttfamily nda\+::matrix$<$ dcomplex $>$ cppdlr\+::build\+\_\+k\+\_\+if (\begin{DoxyParamCaption}\item[{int}]{nmax,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{om,  }\item[{\mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}}}]{statistic }\end{DoxyParamCaption})}



Get imaginary frequency discretization of analytic continuation kernel. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nmax} & Imaginary frequency cutoff \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency grid \\
\hline
\mbox{\texttt{ in}}  & {\em statistic} & Particle Statistic\+: Boson or Fermion\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Discretization of analytic continuation kernel on given grid 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a38c50dbbe81c1821676393f8584fb3f6}\label{namespacecppdlr_a38c50dbbe81c1821676393f8584fb3f6}} 
\index{cppdlr@{cppdlr}!build\_k\_it@{build\_k\_it}}
\index{build\_k\_it@{build\_k\_it}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{build\_k\_it()}{build\_k\_it()}}
{\footnotesize\ttfamily nda\+::matrix$<$ double $>$ cppdlr\+::build\+\_\+k\+\_\+it (\begin{DoxyParamCaption}\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{t,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{om }\end{DoxyParamCaption})}



Get imaginary time discretization of analytic continuation kernel. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Imaginary time grid in relative format \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Frequency real grid\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Discretization of analytic continuation kernel on given grid 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a83cde5c4ed014eb53f7c16392a41733e}\label{namespacecppdlr_a83cde5c4ed014eb53f7c16392a41733e}} 
\index{cppdlr@{cppdlr}!build\_rf\_fine@{build\_rf\_fine}}
\index{build\_rf\_fine@{build\_rf\_fine}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{build\_rf\_fine()}{build\_rf\_fine()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::build\+\_\+rf\+\_\+fine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&}]{fine }\end{DoxyParamCaption})}



Build fine composite Chebyshev grid in real frequency. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fine} & Fine grid parameters\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Fine real frequency grid 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a2d46bf12944fe36c90343df67e2d783b}\label{namespacecppdlr_a2d46bf12944fe36c90343df67e2d783b}} 
\index{cppdlr@{cppdlr}!eqptsrel@{eqptsrel}}
\index{eqptsrel@{eqptsrel}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{eqptsrel()}{eqptsrel()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::eqptsrel (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})}



Get grid of equispaced points on \mbox{[}0,1\mbox{]} in relative time format. 


\begin{DoxyParams}{Parameters}
{\em n} & Number of points\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of equispaced points on \mbox{[}0,1\mbox{]} in relative time format 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_af52a76483a86cc380b2bfb324a6fdbcb}\label{namespacecppdlr_af52a76483a86cc380b2bfb324a6fdbcb}} 
\index{cppdlr@{cppdlr}!free\_gf@{free\_gf}}
\index{free\_gf@{free\_gf}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{free\_gf()}{free\_gf()}}
{\footnotesize\ttfamily template$<$typename Ht $>$ \newline
requires (std\+::floating\+\_\+point$<$Ht$>$ $\vert$$\vert$ nda\+::\+Memory\+Matrix$<$Ht$>$)\\
auto cppdlr\+::free\+\_\+gf (\begin{DoxyParamCaption}\item[{double}]{beta,  }\item[{\mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} const \&}]{itops,  }\item[{Ht const \&}]{h,  }\item[{double}]{mu = {\ttfamily 0} }\end{DoxyParamCaption})}



Compute free-\/particle imaginary time Green\textquotesingle{}s function for a given Hamiltonian. 

The Green\textquotesingle{}s function is computed by diagonalizing the Hamiltonian, and is returned by its values at the DLR imaginary time nodes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em beta} & Inverse temperature \\
\hline
\mbox{\texttt{ in}}  & {\em it} & \mbox{\hyperlink{classcppdlr_1_1imtime__ops}{imtime\+\_\+ops}} object \\
\hline
\mbox{\texttt{ in}}  & {\em h} & Hamiltonian \\
\hline
\mbox{\texttt{ in}}  & {\em mu} & Chemical potential\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Green\textquotesingle{}s function at DLR imaginary time nodes
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Hamiltonian must either be a symmetric matrix, a Hermitian matrix, or a real scalar. 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_afbfcb627a6ab1115bb02670e7ce61219}\label{namespacecppdlr_afbfcb627a6ab1115bb02670e7ce61219}} 
\index{cppdlr@{cppdlr}!gaussquad@{gaussquad}}
\index{gaussquad@{gaussquad}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{gaussquad()}{gaussquad()}}
{\footnotesize\ttfamily std\+::tuple$<$ nda\+::vector$<$ double $>$, nda\+::vector$<$ double $>$ $>$ cppdlr\+::gaussquad (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})}



Gauss-\/\+Legendre nodes and weights. 

Uses Newton iteration to obtain the Gauss-\/\+Legendre nodes and weights


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & Number of nodes\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple of nodes and weights 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a48fb848c5a66d6141ad240d2e749aec9}\label{namespacecppdlr_a48fb848c5a66d6141ad240d2e749aec9}} 
\index{cppdlr@{cppdlr}!geterr\_k\_it@{geterr\_k\_it}}
\index{geterr\_k\_it@{geterr\_k\_it}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{geterr\_k\_it()}{geterr\_k\_it()}}
{\footnotesize\ttfamily std\+::tuple$<$ double, double $>$ cppdlr\+::geterr\+\_\+k\+\_\+it (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcppdlr_1_1fineparams}{fineparams}} \&}]{fine,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{t,  }\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{om,  }\item[{nda\+::matrix\+\_\+const\+\_\+view$<$ double $>$}]{kmat }\end{DoxyParamCaption})}



Get error of fine composite Chebyshev discretization of analytic continuation kernel in imaginary time. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fine} & Fine grid parameters \\
\hline
\mbox{\texttt{ in}}  & {\em t} & Imaginary time grid in relative format \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency grid \\
\hline
\mbox{\texttt{ in}}  & {\em kmat} & Discretization of analytic continuation kernel on given grid\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Error of given fine discretization of analytic continuation kernel in imaginary time and real frequency
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Error is given as an estimate of the maximum absolute value of the difference between the given discretization and the exact analytic continuation kernel

{\ttfamily kmat} should be computed using the function get\+\_\+kfine with composite Chebyshev grids produced by get\+\_\+omfine and get\+\_\+tfine 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_af8f77e12b089b5ddb5b5b3cda18cf623}\label{namespacecppdlr_af8f77e12b089b5ddb5b5b3cda18cf623}} 
\index{cppdlr@{cppdlr}!k\_if@{k\_if}}
\index{k\_if@{k\_if}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_if()}{k\_if()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::complex$<$ double $>$ cppdlr\+::k\+\_\+if (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{double}]{om,  }\item[{\mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}}}]{statistic }\end{DoxyParamCaption})}



Evaluate analytic continuation kernel in imaginary frequency using dimensionless variables (beta = 1) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & Imaginary frequency index \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency value \\
\hline
\mbox{\texttt{ in}}  & {\em statistic} & Particle Statistic\+: Boson or Fermion\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value K(i nu\+\_\+n,om) of analytic continuation kernel
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The definition of the analytic continuation kernel using dimensionless variables is K(i nu\+\_\+n, om) = 1 / (i nu\+\_\+n -\/ om) with i nu\+\_\+n = (2n+1) $\ast$ i $\ast$ pi (fermionic case) or i nu\+\_\+n = 2n $\ast$ i $\ast$ pi (bosonic case). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a672098c598c55c8f9da60cd194a741ea}\label{namespacecppdlr_a672098c598c55c8f9da60cd194a741ea}} 
\index{cppdlr@{cppdlr}!k\_if@{k\_if}}
\index{k\_if@{k\_if}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_if()}{k\_if()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::complex$<$ double $>$ cppdlr\+::k\+\_\+if (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{double}]{om,  }\item[{\mbox{\hyperlink{namespacecppdlr_ad0a7e33d9a03f4986937032c25ee7435}{statistic\+\_\+t}}}]{statistic,  }\item[{double}]{beta }\end{DoxyParamCaption})}



Evaluate analytic continuation kernel in imaginary frequency for a given inverse temperature. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & Imaginary frequency index \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency value \\
\hline
\mbox{\texttt{ in}}  & {\em statistic} & Particle Statistic\+: Boson or Fermion \\
\hline
\mbox{\texttt{ in}}  & {\em beta} & Inverse temperature\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value K(i nu\+\_\+n,om) of analytic continuation kernel
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The definition of the analytic continuation kernel at a given inverse temperature beta is K(i nu\+\_\+n, om) = 1 / (i nu\+\_\+n -\/ om) with i nu\+\_\+n = (2n+1) $\ast$ i $\ast$ pi / beta (fermionic case) or i nu\+\_\+n = 2n $\ast$ i $\ast$ pi / beta (bosonic case). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_ab73f52d9e0209e584d1210d419f39f8c}\label{namespacecppdlr_ab73f52d9e0209e584d1210d419f39f8c}} 
\index{cppdlr@{cppdlr}!k\_if\_boson@{k\_if\_boson}}
\index{k\_if\_boson@{k\_if\_boson}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_if\_boson()}{k\_if\_boson()}}
{\footnotesize\ttfamily std\+::complex$<$ double $>$ cppdlr\+::k\+\_\+if\+\_\+boson (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{double}]{om }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecppdlr_a66270b210c46b39737f361467f645be7}\label{namespacecppdlr_a66270b210c46b39737f361467f645be7}} 
\index{cppdlr@{cppdlr}!k\_if\_fermion@{k\_if\_fermion}}
\index{k\_if\_fermion@{k\_if\_fermion}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_if\_fermion()}{k\_if\_fermion()}}
{\footnotesize\ttfamily std\+::complex$<$ double $>$ cppdlr\+::k\+\_\+if\+\_\+fermion (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{double}]{om }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacecppdlr_afc9726e02898098dfff8448f02f5b3c6}\label{namespacecppdlr_afc9726e02898098dfff8448f02f5b3c6}} 
\index{cppdlr@{cppdlr}!k\_it@{k\_it}}
\index{k\_it@{k\_it}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_it()}{k\_it()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double cppdlr\+::k\+\_\+it (\begin{DoxyParamCaption}\item[{double}]{t,  }\item[{double}]{om }\end{DoxyParamCaption})}



Evaluate analytic continuation kernel in imaginary time (relative time format) using dimensionless variables (beta = 1) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Imaginary time value (relative format) \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value K(t,om) of analytic continuation kernel
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -\/exp(-\/t $\ast$ om)/(1 + exp(-\/om)). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a3cfc4afda9cacac00e93425fe9d45a93}\label{namespacecppdlr_a3cfc4afda9cacac00e93425fe9d45a93}} 
\index{cppdlr@{cppdlr}!k\_it@{k\_it}}
\index{k\_it@{k\_it}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_it()}{k\_it()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double cppdlr\+::k\+\_\+it (\begin{DoxyParamCaption}\item[{double}]{t,  }\item[{double}]{om,  }\item[{double}]{beta }\end{DoxyParamCaption})}



Evaluate analytic continuation kernel in imaginary time (relative time format) for a given inverse temperature. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Imaginary time value (relative format) \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency value \\
\hline
\mbox{\texttt{ in}}  & {\em beta} & Inverse temperature\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value K(t,om) of analytic continuation kernel
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The definition of the analytic continuation kernel at a given inverse temperature beta is K(t,om) = -\/exp(-\/t$\ast$om)/(1+exp(-\/beta $\ast$ om)). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_a7dfaf907221eb1768418258421af703f}\label{namespacecppdlr_a7dfaf907221eb1768418258421af703f}} 
\index{cppdlr@{cppdlr}!k\_it\_abs@{k\_it\_abs}}
\index{k\_it\_abs@{k\_it\_abs}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{k\_it\_abs()}{k\_it\_abs()}}
{\footnotesize\ttfamily double cppdlr\+::k\+\_\+it\+\_\+abs (\begin{DoxyParamCaption}\item[{double}]{t,  }\item[{double}]{om }\end{DoxyParamCaption})}



Evaluate analytic continuation kernel in imaginary time (absolute time format) using dimensionless variables (beta = 1) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & Imaginary time value (absolute format) \\
\hline
\mbox{\texttt{ in}}  & {\em om} & Real frequency value\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Value K(t,om) of analytic continuation kernel
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The definition of the analytic continuation kernel using dimensionless variables is K(t,om) = -\/exp(-\/t $\ast$ om)/(1 + exp(-\/om)). 
\end{DoxyNote}
\mbox{\Hypertarget{namespacecppdlr_adcede29d3876b4a265f09a56db33085d}\label{namespacecppdlr_adcede29d3876b4a265f09a56db33085d}} 
\index{cppdlr@{cppdlr}!leg\_eval@{leg\_eval}}
\index{leg\_eval@{leg\_eval}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{leg\_eval()}{leg\_eval()}}
{\footnotesize\ttfamily std\+::tuple$<$ double, double $>$ cppdlr\+::leg\+\_\+eval (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{double}]{x }\end{DoxyParamCaption})}



Evaluate Legendre polynomial of degree n and its derivative. 

Uses Legendre three-\/term recurrence


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & Degree of polynomial Pn(x) \\
\hline
\mbox{\texttt{ in}}  & {\em x} & Point at which to evaluate polynomial\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple of polynomial value Pn(x) and derivative Pn\textquotesingle{}(x) 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a3d95a6e52d5747f0ea12b91160734e8d}\label{namespacecppdlr_a3d95a6e52d5747f0ea12b91160734e8d}} 
\index{cppdlr@{cppdlr}!pivrgs@{pivrgs}}
\index{pivrgs@{pivrgs}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{pivrgs()}{pivrgs()}}
{\footnotesize\ttfamily template$<$nda\+::\+Memory\+Array\+Of\+Rank$<$ 2 $>$ T, typename S  = get\+\_\+value\+\_\+t$<$\+T$>$$>$ \newline
requires (nda\+::is\+\_\+scalar\+\_\+v$<$S$>$)\\
std\+::tuple$<$ typename T\+::regular\+\_\+type, nda\+::vector$<$ double $>$, nda\+::vector$<$ int $>$ $>$ cppdlr\+::pivrgs (\begin{DoxyParamCaption}\item[{T const \&}]{a,  }\item[{double}]{eps }\end{DoxyParamCaption})}



Rank-\/revealing pivoted reorthogonalized Gram-\/\+Schmidt. 

Determine the epsilon-\/rank of a matrix and return an orthogonal basis of its epsilon-\/row space.

This is a translation of the Fortran subroutine \char`\"{}qrdgrm\char`\"{} by V. Rokhlin.


\begin{DoxyParams}{Parameters}
{\em a} & Matrix to be orthogonalized \\
\hline
{\em eps} & Rank cutoff tolerance\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple of (1) matrix containing whose rows form orthogonal basis of row space of {\ttfamily a} to {\ttfamily eps} tolerance, (2) vector with entry n given by the squared l2 norm of the orthogonal complement of nth selected row with respect to subspace spanned by first n-\/1 selected rows, (3) vector of pivots 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacecppdlr_a3b1ccba6393dfc517757677a13ad2553}\label{namespacecppdlr_a3b1ccba6393dfc517757677a13ad2553}} 
\index{cppdlr@{cppdlr}!rel2abs@{rel2abs}}
\index{rel2abs@{rel2abs}!cppdlr@{cppdlr}}
\doxysubsubsection{\texorpdfstring{rel2abs()}{rel2abs()}}
{\footnotesize\ttfamily nda\+::vector$<$ double $>$ cppdlr\+::rel2abs (\begin{DoxyParamCaption}\item[{nda\+::vector\+\_\+const\+\_\+view$<$ double $>$}]{t }\end{DoxyParamCaption})}



Convert points on \mbox{[}0,1\mbox{]} from relative to absolute time format. 


\begin{DoxyParams}{Parameters}
{\em t} & Vector of points on \mbox{[}0,1\mbox{]} in relative time format\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of points on \mbox{[}0,1\mbox{]} in absolute time format
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Converting a point from relative to absolute time format will, in general, result in a loss of relative accuracy in the location of the point if the point is close to t = 1. For example, in three-\/digit arithmetic, the point t = 0.\+999111 could be stored in relative format as t$^\wedge$$\ast$ = -\/0.\+889e-\/3, but only as t = 0.\+999 in absolute format. For more information on the relative time format used in cppdlr, please see the Background section of the cppdlr documentation. 
\end{DoxyNote}
